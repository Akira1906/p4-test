This directory contains 4 very similar P4_16 programs.

They should contain nothing surprising, except they define 3 `type`
types for Ethernet, IPv4, and "AndyCustom" addresses.  I created the
AndyCustom addresses just to be another custom type on which one might
want P4Runtime translation support, and they are also 32 bits wide,
like IPv4 addresses.

So ideally -- ideally for P4 developer convenience, but not
necessarily the convenience of P4 compiler/control-plane-API
developers -- one might want to be able to do arithmetic on two 32-bit
values, one with type IPv4Addr_t, the other with type
AndyCustomAddr_t, and you would like to use as few casts as possible.

The differences between those 4 programs are only in a handful of
lines.  I'd recommend reading and understanding one of them, then just
doing 'diff' between pairs of them to see what the few lines are that
differ.

Numbers 1 through 3 can all be compiled using the 2020-Mar version of
the open source p4c compiler, and two of the variants generate custom
types for a table key, whereas the other uses `bit<32>`, just as an
example of what is possible and legal today according to the spec and
existing open source implementation.  P4Info info files generated by
today's p4c are also published here.

All of those 3 use multiple casts to get the job done.

Now look at number 4, which has no casts, and the comments above it.
It does not compile, because it tries to do arithmetic on two values
with different types.

Even if it were legal, what would you say the type of the table key
should be?

I only see these two possibilities available, but there might be
others I am not thinking of right now:

+ we need to disallow that program 4 from being legal

or:

+ we need a deterministic rule to predict for _all_ expressions that
  might legally be used as a table key, what its type should be in the
  auto-generated control plane API.  It is possible to make such
  deterministic rules, but what do you propose they should be?
