# Introduction

Caveat emptor: I do not claim to have encyclopedic knowledge of TCP
options, nor to have ever written TCP option parsing code "for real",
i.e. as part of a project where I was responsible for deploying it
into production use, and fixing bugs that arose due to errors or
omissions.  People who do that tend to learn all kinds of details that
I have not.

The P4_16 program `look-for-ts-tcp-option.p4` in this directory has
several `#include` preprocessor directives.  Those files contain very
repetitive code that can be generated by running the Python program
`generate.py`.  See the [`code-generation`](/code-generation/)
directory for an introduction to this technique, if you are not
familiar with it.

The goal with this program is:

+ Look for a TCP Timestamp option in packets that begin with an
  Ethernet, then IPv4, then TCP header.
+ If one is found, extract its fields into some P4 variables, that can
  then be processed however you wish to write P4 code for.  In this
  example code, it simply adds 1 to the timestamp of the packet.
+ Update the TCP header checksum field, if any changes were made to
  the time stamp field.

Below is some pseudocode that implements the first step above.  It is
written in C, or something very close to it (I have not checked
whether it compiles using a C compiler).  I would not call it brief,
but hopefully it is at least clear how it behaves, to anyone with at
least some familiarity with C-like programming languages (e.g. C++,
Java, even Python knowledge should help you understand most of it
without trouble).

I do not see any way to make that code significantly shorter or
simpler, and yet still accomplish the task that it does.  One could
simplify it a bit by accomplishing a simpler task, for example: "find
the TCP Timestamp option, but only if it appears as the first TCP
option, except perhaps skip over up to 2 NOP options if they appear
before the Timestamps option".

It _is_ shorter than the P4 version of the code that is generated to
behave like this pseudocode, because the pseudocode takes advantage of
a `while` loop and an array of bytes (type `uint8_t`) called
`tcp_options` that can be indexed at a byte offset that is a run-time
variable.

```
// See this document for a longer list of TCP options that have been
// proposed.  I do not know exactly which of them are in common use,
// but I believe all of the ones listed here are commonly used.  There
// might be others not included here that are also commonly used, and
// I simply do not know that.

// "Transmission Control Protocol (TCP) Parameters", Last updated
// 2019-07-26,
// https://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml

#define TCP_OPTION_END_OF_OPTIONS 0    // End of Option List - RFC 793
#define TCP_OPTION_NOP            1    // No-Operation - RFC 793
#define TCP_OPTION_MSS            2    // Maximum Segment Size - RFC 793
#define TCP_OPTION_WINDOW_SCALE   3    // Window Scale - RFC 7323
#define TCP_OPTION_SACK_PERMITTED 4    // SACK Permitted - RFC 2018
#define TCP_OPTION_SACK           5    // SACK - RFC 2018
#define TCP_OPTION_TIMESTAMPS     8    // Timestamps - RFC 7323


    // Inputs expected to be initialized correctly before this
    // pseudocode executes.
    uint8_t tcp_options[40];
    int options_length = (hdr.tcp.dataOffset << 2) - 20;
    // Assume that hdr.tcp.dataOffset has already been checked that it
    // is at least 5, so options_length is guaranteed to be a multiple
    // of 4 in the range [0, 40].

    // Output values
    bool found_ts_option = FALSE;
    int offset = 0;

    // temporary variables
    uint8_t option_kind;
    bool known_option;
    bool kind_followed_by_length;
    bool fixed_length;
    uint8_t expected_fixed_length;
    uint8_t option_len_bytes;

    while (offset < options_length) {
        option_kind = tcp_options[offset];
        // See definition of get_option_kind_info below.  Given a TCP
        // option kind byte value, it determines whether that option
        // kind is known to this implementation, whether there
        // should be a length byte following the kind byte, whether
        // the option is fixed or variable length, and if fixed
        // length, what length it should be.
        get_option_kind_info(option_kind, &known_option,
                      &kind_followed_by_length, &fixed_length,
                      &expected_fixed_length);
        if (!known_option) break;
        if (kind_followed_by_length) {
            if ((offset + 1) >= options_length) {
                // malformed TCP options - fell off end of TCP options header
                break;
            }
            option_len_bytes = tcp_options[offset+1];
            if (fixed_length && (option_len_bytes != expected_fixed_length)) {
                // malformed TCP options - incorrect length
                break;
            }
            // This code assumes that if fixed_length is FALSE, the
            // length in the packet is correct.  For the SACK option,
            // it is possible to check that the option length is one
            // of a few legal values.  See parser state
            // 'parse_tcp_options_sack' in the program
            // tcp-options-parser.p4 for some details on this.
        } else {
            option_len_bytes = 1;
        }
        if ((offset + option_len_bytes) > options_length) {
            // option is too long to fit in packet's TCP options
            break;
        }
        // This code stops when the first Timestamps option is found.
        if (option_kind == TCP_OPTION_TIMESTAMPS) {
            found_ts_option = TRUE;
	    break;
        }
        if (option_kind == TCP_OPTION_END_OF_OPTIONS) {
            // Stop if End of Options option is encountered.
            break;
        }
        offset = offset + option_len_bytes;
    }

    // Now if found_ts_option is TRUE, it should begin at the byte
    // offset in the variable 'offset'.  Otherwise, it could be that
    // some other TCP option not recognized by get_option_kind_info()
    // was encountered, and there really is a Timestamp option in the
    // packet, after that unrecognized one.

    if (found_ts_option) {
        // get_uint32_at_byte_offset is defined below, and simply gets
        // 4 consecutive bytes and appends them together into a 32-bit
        // unsigned integer, in network byte order (i.e big endian,
        // most significant byte first).
        uint32_t TSval = get_uint32_at_byte_offset(tcp_options, offset + 2);
        uint32_t TSecr = get_uint32_at_byte_offset(tcp_options, offset + 6);

        // Do anything else here that you want with the TSval and
        // TSecr values.
    }

get_option_kind_info (uint8_t in_option_kind,
                      bool *out_known_option,
                      bool *out_kind_followed_by_length,
                      bool *out_fixed_length,
                      uint8_t *out_expected_fixed_length)
{
    *out_known_option = TRUE;
    switch (in_option_kind) {
    case TCP_OPTION_END_OF_OPTIONS:
        *out_kind_followed_by_length = FALSE;
        break;
    case TCP_OPTION_NOP:
        *out_kind_followed_by_length = FALSE;
        break;
    case TCP_OPTION_MSS:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 4;
        break;
    case TCP_OPTION_WINDOW_SCALE:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 4;
        break;
    case TCP_OPTION_SACK_PERMITTED:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 2;
        break;
    case TCP_OPTION_SACK:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = FALSE;
        break;
    case TCP_OPTION_TIMESTAMPS:
        *out_kind_followed_by_length = TRUE;
        *out_fixed_length = TRUE;
        *out_expected_fixed_length = 10;
        break;
    default:
        *out_known_option = FALSE;
        break;
    }
}

uint32_t get_uint32_at_byte_offset(uint8_t in_tcp_options[],
                                   int in_byte_offset)
{
    int i = in_byte_offset;
    uint32 ret;

    ret = ((((uint32_t) in_tcp_options[i+0]) << 24) |
           (((uint32_t) in_tcp_options[i+1]) << 16) |
           (((uint32_t) in_tcp_options[i+2]) <<  8) |
           (((uint32_t) in_tcp_options[i+3]) <<  0));
    return ret;
}

```

My P4 version of this pseudocode "unrolls" the loop to some maximum
number of iterations that you can change if you wish, and avoids using
run-time variable array indexes.  Both of those results are achieved
in the same way as demonstrated in the example programs in the
[`code-generation`](/code-generation/) directory.

TBD: Give detailed instructions on how to change this maximum number
of iterations.

There are options in modifying this program that can make it more or
less useful for particular purposes.

One of the primary choices to make is how many TCP options to parse
while searching for a TCP timestamp option.  The options portion of a
TCP header can be up to 40 bytes in length.

Unlike some of the other example P4 programs in this repository
dealing with parsing TCP options, this one does not create a separate
header type for each TCP option, but actually does something like what
a P4 parser does in the ingress control.  It does this to avoid using
P4 header stacks and `header_union` types.  There are other ways to
achieve the goal besides the examples in this repository, though, so
do not take the lack of another style of example program as me
claiming "it cannot be done any other way" -- it certainly can be [2].

I doubt that any TCP implementations in common use create 40 bytes of
options that consist of 30 1-byte NOP options (a single byte equal to
0), followed by a 10-byte long timestamp option, and this might even
be prohibited by some RFC somewhere that I have not read, but if it is
not prohibited, it appears legal to create such a packet.

The code in this directory executes at least one separate `if`
statement for each TCP option that occurs before the timestamp option
is found, and the condition for each is data-dependent upon earlier
TCP options found, so cannot be parallelized inan automatic way.  Some
P4 implementations may have relatively tight limits on how many such
sequentially dependent operations they can perform, and while this
program along might not stretch those limits, if you want to use this
code as only one kind of packet processing among many that you wish to
perform, it can add up quickly.

[1]

Documents, especially RFCs, references examined while writing this
example code (perhaps only briefly -- no claim of complete, nor even
thorough, knowledge is made here).

"Transmission Control Protocol (TCP) Parameters", Last updated
2019-07-26,
https://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml

RFC 793, "Transmission Control Protocol", September 1981,
https://tools.ietf.org/html/rfc793

RFC 7323, "TCP Extensions for High Performance", September 2014,
https://tools.ietf.org/html/rfc7323


[2]

One could use techniques similar to a kangaroo parser (see below) in
the ingress control to reduce the number of dependent iterations
required to get to the timestamp option, at least for some sequences
of TCP options, making the code easier to "fit" into certain P4
targets, with the tradeoff that the code is a bit more complex to
understand and maintain.

This suggestion might sound confusing.  You may be wondering: don't P4
implementations often use techniques like kangaroo parsers in their
implementation of a P4 `parser` construct?  Yes, some likely do that.
So yes, my suggestion that you could write code to use that technique
in a P4 `control` may sound odd, but that does not make it impossible.
There might be situations where it is even desirable to do.

+ "Leaping multiple headers in a single bound: wire-speed parsing
  using the Kangaroo system", Christos Kozanitis, John Huber, Sushil
  Singh, George Varghese,
  http://cseweb.ucsd.edu/~ckozanit/files/infocom2010.pdf
